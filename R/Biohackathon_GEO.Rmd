---
title: 'BioHackathon 2017'
output:
  html_document: default
  html_notebook: default
---

---

#### Contents:

* [Introduction](#introduction)
* [Microarray Data Workflow](#data1)
* [RNA-Seq Data Workflow](#data2)
* [Retrieving Metadata](#metadata)
* [Workflow Reproduciblity](#repo)



---
    
<a name="introduction"/> 

# Introduction
This script is designed to download and process data from [GEO](https://www.ncbi.nlm.nih.gov/geo/). For each downloaded dataset, the data is processed and converted into an expression matrix (rows are genes and columns are samples). Additionally, using the [GEO Metadata Database](https://www.ncbi.nlm.nih.gov/geo/info/geo_paccess.html) specific features for each dataset are collected and kept for downstream processing. Prior to running differential expression analysis, the expression data is verified to ensure both normalization and log transformation had been performed. The RNA-seq data is put through additional verification to ensure that it has been run through [voom](http://web.mit.edu/~r/current/arch/i386_linux26/lib/R/library/limma/html/voom.html). This additional step permits the same limma pipeline to be used for both processed microarray and RNA-seq data ([Law et al., 2014](https://www.ncbi.nlm.nih.gov/pubmed/24485249), [limma user guide](http://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf)).


```{r message=FALSE, warning=FALSE}
# load needed libraries
library(Biobase)
library(data.table)
library(edgeR)
library(EMA)
library(GEOmetadb)
library(GEOquery)
library(ggplot2)
library(Glimma)
library(gplots)
library(knitr)
library(latex2exp)
library(limma)
library(Mus.musculus)
library(mygene)
library(RColorBrewer)
library(R.utils)
```

<a name="data1"/>   

## Microarray Data
### Accessing GEO Data
Microarray data is downloaded from GEO as a GEO Series, from which an expression set and gene expression matrix are derived.
```{r warning=FALSE, message= FALSE, eval=FALSE, cache=TRUE}
# Use the getGEO() function to download the GEO data for the id
gse_data <- GEOquery::getGEO('GSE14722', GSEMatrix=TRUE, AnnotGPL=FALSE)

# create gene expression set. If multiple data sets, take the first one and retrieve platform-specific annotation information
if (length(gse_data) > 1) idx <- grep(gse_data[[1]]@annotation, attr(gse_data, 'names')) else idx <- 1
```

```{r warning=FALSE, eval=FALSE, cache=TRUE}
# specify GEO accession id
id = 'GSE14722'

# view dataset information
gse_exp_set <- gse_data[[idx]]
gse_exp_set

# update column names
Biobase::fvarLabels(gse_exp_set) <- make.names(Biobase::fvarLabels(gse_exp_set))

# convert expression set to expression matrix
exprs_data <- Biobase::exprs(gse_exp_set)

# store gene names and samples
GSE_genes = data.frame(rownames(exprs_data), 
                       gse_data[[1]]@featureData@data$ENTREZ_GENE_ID,
                       gse_data[[1]]@featureData@data$`Gene Symbol`)
names(GSE_genes) = c('probe', 'Genes.ENTREZID', 'Genes.SYMBOL')
samples = colnames(exprs_data)

# set group membership for all samples
groups = as.character(lapply(as.character(gse_exp_set@phenoData@data$source_name_ch1), function(x)
                             ifelse(length(grep('clampsia', x)) == 1,
                             'preeclampsia', 'preterm')))
groups
```

### Pre-Processing and Quality Control
Prior to determining which genes are differentially expressed, the preprocessing performed by the submitter of the data is verified. Specifically, the data is checked to ensure normalization and log transformation. For example, if in the data have been pre-processed with RMAExpress then the data should have had convolution background correction, quantile normalization, and summarization using median polish. This also indicates that the expression values are on $log_{2}$ scale. Additional verification performed on the data includes checking for 'NA' values, removing duplicate genes, filtering out lowly expressed genes, and verifying sample clustering.
```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
# check metadata to determine if RMA was used during pre-processing
grepl('RMA', gse_exp_set@phenoData@data$data_processing[1])

# create box plots to verify pre-processing
boxplot(exprs_data, col = brewer.pal(9, 'Set1'), 
        cex.axis = 0.5, cex.lab = 0.65, las=2,
        ylab = TeX('$log_{2}$ Intensity'))

# check for NA values
cat('There are', sum(is.na(exprs_data)), 'NA values')

# remove duplicate gene names
exprs_data_clean = exprs_data[!duplicated(rownames(exprs_data)),]

## Filtering
# summarize average gene expression values
avg <- rowMeans(exprs_data_clean)
summary(avg)

# view distribution to determine whether or not filtering is needed
EMA::expFilter(exprs_data_clean, threshold = FALSE, graph = TRUE)

# # filter and discard probesets with a maximum log2 expression value below x, p=0.01
# PUBHI.f = expFilter(PHBI.exprs, threshold=x) 
```

If the expression data have been both normalized and log transformed the samples will have similar $log_{2}$ intensity distributions (first plot). If the data has been filtered the distribution should appear somewhat 'normal' (second plot).  

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
# cluster expression data by sample
sample = EMA::clustering(data = exprs_data_clean, metric = 'pearson', method = 'average')
EMA::clustering.plot(tree = sample, lab = groups, title = 'Filtered Data', scale='row', legend.pos = 'topleft')
```

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
## Principle Components Analysis
# segment variation into different components
acp = EMA::runPCA(t(exprs_data_clean), scale = FALSE, lab.sample = groups, plotSample = FALSE, plotInertia = FALSE)
names(acp$eig) = c('eigen', '%var', 'cumm %var')

knitr::kable(head(acp$eig))
# EMA::plotInertia(acp)

# view variation between samples
EMA::plotSample(acp, axes = c(1, 2), lab = groups)

# save cleaned expression data
exp = as.data.frame(cbind(rownames(exprs_data_clean), exprs_data_clean))
names(exp) = c('probe', colnames(exprs_data_clean))
write.table(exp, file = paste('GEO_Data/', id, '_clean_exp_data.txt', sep = ' '), 
            sep = '\t',
            row.names = FALSE,
            col.names = TRUE,
            quote = FALSE)
```
Samples appear to cluster by their grouping providing evidence that the set of genes may be differentially expressed.  


## Differential Expression Analysis
Differential expression analysis was performed on the pre-processed microarray data using limma ( [microarray](http://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf)).
```{r cache=TRUE, echo=TRUE, error = FALSE, vmessage=FALSE, warning=FALSE, eval=TRUE}
## Run Differential Expression Analysis
# create design matrix
design <- stats::model.matrix(~ groups + 0, data.frame(exprs_data_clean))
colnames(design) <- gsub('groups', '', colnames(design))
design

# create constrast
contr.matrix <- limma::makeContrasts(
   PEvsPT = preeclampsia-preterm, 
   levels = colnames(design))
contr.matrix

# fit model
fit <- limma::lmFit(data.frame(exprs_data_clean), design)
fit <- limma::contrasts.fit(fit, contrasts=contr.matrix)
efit <- limma::eBayes(fit)

# get results adjusting for multiple testing using FDR
results = limma::topTable(efit, coef=1, adjust='fdr', lfc=0, number=Inf)
knitr::kable(head(results, n = 10))

# add gene information to efit
efit$genes <- GSE_genes

# print number of up and down regulated genes between the samples
top_dec_test <- decideTests(efit)
knitr::kable(summary(top_dec_test))

# print diagram of up and down regulated genes
plotMD(efit, column=1, status=top_dec_test[,1], main=colnames(efit)[1], cex = 0.7)

## Process Results
limma::write.fit(efit, top_dec_test, adjust='fdr', file=paste('DE_Results/', id ,'_DEgenes.txt', sep = ' '))
```
The plot shows the up (red) and down (green) regulated differentially expressed genes between the samples.  

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
## Visualize results
# volcano plot
ggplot2::theme_update(plot.title = element_text(hjust = 0.5))
ggplot2::ggplot(data = results, aes(x = results$logFC, y = -log10(results$adj.P.Val)), colour = none) + 
       geom_point(alpha = 0.4, size = 1.75) + 
       labs(title = paste(id, ': Volcano Plot', sep = ' ')) + 
       xlim(c(ceiling(-max(results$logFC)), ceiling(max(results$logFC)))) + 
       ylim(c(0, ceiling(max(-log10(results$adj.P.Val))))) +
       ylab(TeX('$-log_{10}$ P-Value')) + 
       xlab(TeX('$log_{2}$ Fold Change'))
```

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
# heatmap - top 100 genes
mvgenes = as.character(rownames(results)[1:100])
c.sample <- EMA::clustering(data = exprs_data_clean[mvgenes, ], metric = 'pearson', method = 'ward')
c.gene <- EMA::clustering(data = t(exprs_data_clean[mvgenes, ]), metric = 'pearson', method = 'ward')
EMA::clustering.plot(tree = c.sample, tree.sup = c.gene, data = exprs_data_clean[mvgenes, 
    ], names.sup = FALSE, lab = groups, trim.heatmap = 0.99, scale = 'row')
```

<a name="data2"/>   

## Accessing GEO Data
### RNA-Seq Data
RNA-Seq data is a bit more complicated to analyze then the microarray data. To get expression data, the count data data needs to be downloaded and fully processed. The [Bioconductor RNA-Seq Workflow](https://www.bioconductor.org/help/workflows/RNAseq123/) developed by the [Smyth Lab](https://www.wehi.edu.au/people/gordon-smyth) was used.
```{r warning=FALSE, eval=FALSE}
## Download Data
id <- 'GSE63310'
url <- paste('https://www.ncbi.nlm.nih.gov/geo/download/?acc=', id, '&format=file', sep = '')
utils::download.file(url, destfile=paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''), mode='wb')
  
# unzip data to directory, where directory has same name as id
utils::untar(paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''), exdir = paste('Raw_GEO_Data/',
                                                                           id, sep=''))
# list all files in directory
files <- list.files(path = paste('Raw_GEO_Data/', id, sep=''), full.names=TRUE)

# check to see if data has already been extracteds before extracting
if(!any(grepl('*.txt$', files))){
  # unzip sub-directories
  sapply(files, function(i) R.utils::gunzip(i, overwrite = TRUE))
  
} else {
  # delete them
  lapply(files, function(x) file.remove(x,
  pattern = "*.txt$", 
  full.names = TRUE))
  
  # download data
  utils::download.file(url, destfile=paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''), mode='wb')
  
  # unzip data to directory, where directory has same name as id
  utils::untar(paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''), exdir = paste('Raw_GEO_Data/', id, sep=''))
  
  # list all files in   directory
  files <- list.files(path = paste('Raw_GEO_Data/', id, sep=''), full.names=TRUE)
  
  # then extract new data
  sapply(files, function(i) R.utils::gunzip(i, overwrite = TRUE))
}

# delete zipped file
file.remove(paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''))

# download series information on samples
gse <- GEOquery::getGEO('GSE63310', GSEMatrix = TRUE)

# get group info - remove samples we are not including (i.e., 3 and 9)
group_info = as.character(gse[[1]]@phenoData@data$title)[-c(3, 9)]

# get batch info
batch_info = as.character(gse[[1]]@phenoData@data$characteristics_ch1.6)[-c(3, 9)]
```

```{r warning=FALSE, eval=TRUE, cache=TRUE}
# specify GEO accession id
id <- 'GSE63310'

# read in text files and create single matrix of counts
unzipped_files <- list.files(path = paste('Raw_GEO_Data/', id, sep=''), full.names=TRUE)[-c(3, 9)]

# review file
head(read.table(unzipped_files[1]))

# crete DGE object
DGE <- edgeR::readDGE(unzipped_files, columns=c(1,3))

# remove GEO sample IDs from column names
samplenames <- substring(colnames(DGE), nchar(paste('Raw_GEO_Data/', id, sep='')) + 13, nchar(colnames(DGE)))
colnames(DGE) <- samplenames
samplenames

# create groups
group = as.factor(as.character(lapply(samplenames, function(x) sub(',.*', '', group_info[grepl(x, group_info)]))))
group

# DGEList-object contains a samples data frame that stores both cell type (or group) and batch (sequencing lane) informations
DGE$samples$group <- group
lane <- as.factor(as.character(lapply(batch_info, function(x) sub(': ', '', x))))
DGE$samples$lane <- lane
head(DGE$samples)
```

```{r warning=FALSE, eval=TRUE, cache=TRUE}
## Get Gene Annotations ##
# get Entrez gene ids from DGEList-object
geneid <- rownames(DGE)
head(geneid)

# get additional gene information
genes <- AnnotationDbi::select(Mus.musculus, keys=geneid, columns=c('SYMBOL'), 
                keytype='ENTREZID')

# # aggregate 1:many mappings into single list
# entrez = aggregate(ENTREZID ~ ENSEMBL, data = genes, paste, collapse = ' /// ')
# symbol = aggregate(SYMBOL ~ ENSEMBL, data = genes, paste, collapse = ' /// ')
# 
# # merge lists together
# gene_merge = merge(entrez, symbol, by = 'ENSEMBL', all = TRUE)

# add this information to DGEList-object
DGE$genes <- genes
```

## Pre-Processing and Quality Control
Prior to determining which genes are differentially expressed, the expression data processing is processed. The pre-processing pipeline includes: log transformation, filtering of lowly expressed genes, normalization, and clustering by sample and lane.
```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
## Log-Transformation
#convert raw count to CPM and log-CPM values
cpm <- edgeR::cpm(DGE)
lcpm <- edgeR::cpm(DGE, log=TRUE)

## Filter Lowly Expressed Genes
# get count of genes with count of 0
table(rowSums(DGE$counts==0)==length(samplenames))
dim(DGE)

# get counts by sample
knitr::kable(data.table(samplenames, counts = as.numeric(lapply(colSums(DGE$counts), function(x) x/1000000))))

# remove genes using cpm > 1 as threshold, where a gene must be expressed in at least 3 samples
keep.exprs <- rowSums(cpm>1) >= 3
DGE <- DGE[keep.exprs,, keep.lib.sizes=FALSE]
dim(DGE)

# visualize density plots before and after filtering
nsamples <- ncol(DGE)
col <- brewer.pal(nsamples, 'Paired')
par(mfrow=c(1,2))
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2, 
     main='', xlab='')
title(main='A. Raw data', xlab='Log-cpm')
abline(v=0, lty=3)
for (i in 2:nsamples){
 den <- density(lcpm[,i])
 lines(den$x, den$y, col=col[i], lwd=2)
}
legend('topright', samplenames, text.col=col, bty='n')
lcpm <- cpm(DGE, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2, 
     main='', xlab='')
title(main='B. Filtered data', xlab='Log-cpm')
abline(v=0, lty=3)
for (i in 2:nsamples){
   den <- density(lcpm[,i])
   lines(den$x, den$y, col=col[i], lwd=2)
}
legend('topright', samplenames, text.col=col, bty='n')
par(mfrow=c(1,1))
#The density of log-CPM values for raw pre-filtered data (A) and post-filtered data (B) are shown for each sample. Dotted vertical lines mark the log-CPM of zero threshold (equivalent to a CPM value of 1) used in the filtering step.
```
The density of log-CPM values for raw pre-filtered data (A) and post-filtered data (B) are shown for each sample. Dotted vertical lines mark the log-CPM of zero threshold (equivalent to a CPM value of 1) used in the filtering step.  

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
## Normalize Expression Distributions
#trimmed mean of M-values (TMM) (Robinson and Oshlack 2010) is performed using the calcNormFactors function in edgeR
DGE <- calcNormFactors(DGE, method = 'TMM')

# box plots to verify pre-processing
boxplot(cpm(DGE, log = TRUE), col = brewer.pal(9, 'Set1'), 
        cex.axis = 0.75, cex.lab = 0.5, las=2, cex.main = 1.0,
        main = paste(id, ': Distribution of Pre-Processed Expression Data by Sample', sep = ' '),
        ylab = 'Log CPM')
```
The samples should have similar $log_{2}$ intensity distributions.   

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
## Clustering by Sample and Sequencing Lane
# SAMPLES
par(mfrow=c(1,2))
col.group <- group
levels(col.group) <-  brewer.pal(nlevels(col.group), 'Set1')
col.group <- as.character(col.group)
plotMDS(cpm(DGE, log = TRUE), labels=group, col= col.group)
title(main='Sample groups')

# SEQUENCING LANES
col.lane <- lane
levels(col.lane) <-  brewer.pal(nlevels(col.lane), 'Set2')
col.lane <- as.character(col.lane)
plotMDS(cpm(DGE, log = TRUE), labels=lane, col=col.lane, dim=c(3,4))
title(main='Sequencing lanes')

par(mfrow=c(1,1))
```
Samples appear to cluster by their grouping providing evidence that the set of genes may be differentially expressed.    


## Differential Expression Analysis
Differential expression analysis was performed on RNA-seq data using limma ([RNA-seq](https://www.bioconductor.org/help/workflows/RNAseq123/)). As mentioned above, once RNA-seq has been processed with voom a similar differential expression analysis pipeline via limma used for microarray data can also be used with RNA-seq data.
```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
# set-up design matrix
design <- stats::model.matrix(~0+group+lane)
colnames(design) <- gsub('group', '', colnames(design))
design

# set-up contrasts - want ocntrol group to be negative
contr.matrix <- makeContrasts(
   BasalvsLP = Basal-LP, 
   BasalvsML = Basal-ML, 
   LPvsML = LP-ML, 
   levels = colnames(design))
contr.matrix
```

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
## remove heteroscedascity from count data - voom
par(mfrow=c(1,2))
v <- voom(DGE, design, plot=TRUE)
v

## fit model
fit <- limma::lmFit(v, design)
fit <- limma::contrasts.fit(fit, contrasts=contr.matrix)
efit <- limma::eBayes(fit)
limma::plotSA(efit, main='Final model: Mean−variance trend')
par(mfrow=c(1,1))
```

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
# print number of up and down regulated genes between the samples
top_dec_test <- decideTests(efit)
knitr::kable(summary(top_dec_test))

# print number of up and down regulated genes
summary(decideTests(efit))

# re-run model with a cut-off of a log-fold change of 1
tfit <- treat(fit, lfc=1)
top_dec_test <- decideTests(tfit)
summary(top_dec_test)

## Process Results
limma::write.fit(tfit, top_dec_test, adjust='fdr', file=paste('DE_Results/', id ,'_DEgenes.txt', sep = ' '))
```


```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE}
# view list of genes significantly expressed across all sample comparisons
de.common <- which(top_dec_test[,1]!=0 & top_dec_test[,2]!=0)
length(de.common)

# visualize in venn diagram
limma::vennDiagram(top_dec_test, circle.col=rainbow(n=3), cex = 0.9)
```


```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE, fig.height=2, fig.width=2}
# MD plot
limma::plotMD(tfit, column=1, status=top_dec_test[,1], main=colnames(tfit)[1], 
       xlim=c(-8,13), cex.axis = 0.5, cex.lab = 0.5, cex.main=0.75)
limma::plotMD(tfit, column=1, status=top_dec_test[,2], main=colnames(tfit)[2], 
       xlim=c(-8,13))
limma::plotMD(tfit, column=1, status=top_dec_test[,3], main=colnames(tfit)[3], 
       xlim=c(-8,13))
```

```{r cache=TRUE, echo=TRUE, vmessage=FALSE, warning=FALSE, eval=TRUE, fig.height=4, fig.width=4}
# get top DEG by group comparisons
basal.vs.lp <- topTreat(tfit, coef=1, n=Inf)
head(basal.vs.lp)

basal.vs.ml <- topTreat(tfit, coef=2, n=Inf)
head(basal.vs.ml)

# heat map
basal.vs.lp.topgenes <- basal.vs.lp$ENTREZID[1:50]
i <- which(v$genes$ENTREZID %in% basal.vs.lp.topgenes)
cols <- colorRampPalette(brewer.pal(10, 'RdBu'))(256)
gplots::heatmap.2(v$E[i,], scale='row',
   labRow=v$genes$SYMBOL[i], labCol=group, col = cols,
   trace='none', density.info='density', dendrogram='column', cexRow = 0.5)
```

<a name="metadata"/> 

## GEO Metadata Retrieval
The GEO Metadata Database is used to retrieve important metadata about GEO data sets used in the current analysis. Specifically, the GES Accession identifier, study type (i.e., expression profiling by array, Expression profiling by high throughput sequencing), PubMed identifier, and the original date that the data was submitted to GEO. 
```{r warning=FALSE, cache=TRUE}
## Connect to database
con <- DBI::dbConnect(SQLite(),'GEO_Database/GEOmetadb.sqlite')

# query a table
metadata <- DBI::dbGetQuery(con,'SELECT gse, pubmed_id, title, summary, submission_date, type, overall_design
                      FROM gse
                      WHERE gse IN ("GSE14722", "GSE63310")')

# print results
knitr::kable(metadata)

# replace tabs with pipes
metadata$title = gsub("\t", " | ", metadata$title)
metadata$summary = gsub("\t", " | ", metadata$summary)
metadata$type = gsub("\t", " | ", metadata$type)
metadata$overall_design = gsub("\t", " | ", metadata$overall_design)

# write metadata to csv
write.table(metadata, 
            'GEO_Data/GES_Metadata.txt', 
            row.names = FALSE, 
            quote = FALSE,
            sep = '\t')

# close db connection
DBI::dbDisconnect(con)
```


<a name="repo"/>  

#### Session Information
```{r eval=TRUE}
sessionInfo()
```